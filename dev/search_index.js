var documenterSearchIndex = {"docs":
[{"location":"#ConstructionBase.jl-1","page":"Home","title":"ConstructionBase.jl","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"","category":"page"},{"location":"#Interface-1","page":"Home","title":"Interface","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"ConstructionBase\nConstructionBase.constructorof\nConstructionBase.setproperties","category":"page"},{"location":"#ConstructionBase","page":"Home","title":"ConstructionBase","text":"ConstructionBase\n\n(Image: Stable) (Image: Dev) (Image: Build Status) (Image: Codecov) (Image: GitHub stars)\n\nConstructionBase is a very lightwight package, that provides primitive functions for construction of objects:\n\nsetproperties(obj::MyType, patch::NamedTuple)\nconstructorof(MyType)\n\nThese functions can be overloaded and doing so provides interoperability with the following packages:\n\nFlatten.jl\nSetfield.jl\nBangBang.jl\n\n\n\n\n\n","category":"module"},{"location":"#ConstructionBase.constructorof","page":"Home","title":"ConstructionBase.constructorof","text":"constructorof(T::Type) -> constructor\n\nReturn an object constructor that can be used to construct objects of type T from their field values. Typically constructor will be the type T with all parameters removed:\n\njulia> using ConstructionBase\n\njulia> struct T{A,B}\n           a::A\n           b::B\n       end\n\njulia> constructorof(T{Int,Int})\nT\n\nIt is however not guaranteed, that constructor is a type at all:\n\njulia> struct S\n           a\n           b\n           checksum\n           S(a,b) = new(a,b,a+b)\n       end\n\njulia> ConstructionBase.constructorof(::Type{<:S}) =\n           (a, b, checksum=a+b) -> (@assert a+b == checksum; S(a,b))\n\njulia> constructorof(S)(1,2)\nS(1, 2, 3)\n\njulia> constructorof(S)(1,2,4)\nERROR: AssertionError: a + b == checksum\n\nInstead constructor can be any object that satisfies the following properties:\n\nIt must be possible to reconstruct an object from its fields:\n\nctor = constructorof(typeof(obj))\n@assert obj == ctor(fieldvalues(obj)...)\n@assert typeof(obj) == typeof(ctor(fieldvalues(obj)...))\n\nThe other direction should hold for as many values of args as possible:\n\nctor = constructorof(T)\nfieldvalues(ctor(args...)) == args\n\nFor instance given a suitable parametric type it should be possible to change the type of its fields:\n\njulia> struct T{A,B}\n           a::A\n           b::B\n       end\n\njulia> t = T(1,2)\nT{Int64,Int64}(1, 2)\n\njulia> constructorof(typeof(t))(1.0, 2)\nT{Float64,Int64}(1.0, 2)\n\njulia> constructorof(typeof(t))(10, 2)\nT{Int64,Int64}(10, 2)\n\nSee also Tips section in the manual\n\n\n\n\n\n","category":"function"},{"location":"#ConstructionBase.setproperties","page":"Home","title":"ConstructionBase.setproperties","text":"setproperties(obj, patch::NamedTuple)\n\nReturn a copy of obj with attributes updates accoring to patch.\n\nExamples\n\njulia> using ConstructionBase\n\njulia> struct S\n           a\n           b\n           c\n       end\n\njulia> s = S(1,2,3)\nS(1, 2, 3)\n\njulia> setproperties(s, (a=10,c=4))\nS(10, 2, 4)\n\njulia> setproperties((a=1,c=2,b=3), (a=10,c=4))\n(a = 10, c = 4, b = 3)\n\nThere is also a convenience method, which builds the patch argument from keywords:\n\nsetproperties(obj; kw...)\n\nExamples\n\njulia> using ConstructionBase\n\njulia> struct S\n           a\n           b\n           c\n       end\n\njulia> o = S(10, 2, 4)\nS(10, 2, 4)\n\njulia> setproperties(o, a=\"A\", c=\"cc\")\nS(\"A\", 2, \"cc\")\n\nImplementation\n\nFor a custom type MyType, a method setproperties(obj::MyType, patch::NamedTuple) may be defined.\n\nPrefer to overload constructorof whenever makes sense (e.g., no getproperty method is defined).  Default setproperties is defined in terms of constructorof.\nIf getproperty is customized, it may be a good idea to define setproperties.\n\nwarning: Warning\nThe signature setproperties(obj::MyType; kw...) should never be overloaded. Instead setproperties(obj::MyType, patch::NamedTuple) should be overloaded.\n\nSpecification\n\nsetproperties guarantees a couple of invariants. When overloading it, the user is responsible for ensuring them:\n\nPurity: setproperties is supposed to have no side effects. In particular setproperties(obj, patch::NamedTuple) may not mutate obj.\nRelation to propertynames and fieldnames: setproperties relates to propertynames and getproperty, not to fieldnames and getfield. This means that any subset p₁, p₂, ..., pₙ of propertynames(obj) is a valid set of properties, with respect to which the lens laws below must hold.\nsetproperties should satisfy the lens laws:\n\nFor any valid set of properties p₁, p₂, ..., pₙ, following equalities must hold:\n\nYou get what you set.\n\nlet obj′ = setproperties(obj, ($p₁=v₁, $p₂=v₂, ..., $pₙ=vₙ))\n    @assert obj′.$p₁ == v₁\n    @assert obj′.$p₂ == v₂\n    ...\n    @assert obj′.$pₙ == vₙ\nend\n\nSetting what was already there changes nothing:\n\n@assert setproperties(obj, ($p₁=obj.$p₁, $p₂=obj.$p₂, ..., $pₙ=obj.$pₙ)) == obj\n\nThe last set wins:\n\nlet obj′ = setproperties(obj, ($p₁=v₁, $p₂=v₂, ..., $pₙ=vₙ)),\n    obj′′ = setproperties(obj′, ($p₁=w₁, $p₂=w₂, ..., $pₙ=wₙ))\n    @assert obj′′.$p₁ == w₁\n    @assert obj′′.$p₂ == w₂\n    ...\n    @assert obj′′.$pₙ == wₙ\nend\n\n\n\n\n\n","category":"function"},{"location":"#type-tips-1","page":"Home","title":"Tips for designing types","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"When designing types from scratch, it is often possible to structure the types in such a way that overloading constructorof or setproperties is unnecessary in the first place.  It let types in your package work nicely with the ecosystem built on top of ConstructionBase even without explicitly depending on it. For simple structs whose type parameters can be determined from field values, ConstructionBase works without any customization, provided that the \"type-less\" constructor exists.  However, it is often useful or required to have type parameters that cannot be determined from field values. One way to solve this problem is to define singleton types that would determine the type parameters:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"abstract type OutputBy end\nstruct Mutating <: OutputBy end\nstruct Returning <: OutputBy end\n\nstruct Add{O <: OutputBy, T}\n    outputby::O\n    value::T\nend\n\n(f::Add{Mutating})(y, x) = y .= x .+ f.value\n(f::Add{Returning})(x) = x .+ f.value\n\nadd1! = Add(Mutating(), 1)\n\nusing ConstructionBase\nadd2 = constructorof(typeof(add1!))(Returning(), 2)\nadd2(1)\n\n# output\n\n3","category":"page"},{"location":"#","page":"Home","title":"Home","text":"setproperties works as well:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"add3 = setproperties(add2; value=3)\nadd3(1)\n\n# output\n\n4","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Note that no overloading of ConstructionBase functions was required. Importantly, this also provides an interface to change type parameters out-of-the-box:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"add3! = setproperties(add3; outputby=Mutating())\nadd3!([0], 1)\n\n# output\n\n1-element Array{Int64,1}:\n 4","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Furthermore, it would work with packages depending on ConstructionBase such as Setfield.jl.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"using Setfield: @set\nadd3′ = @set add3!.outputby = Returning()\nadd3′ === add3\n\n# output\n\ntrue","category":"page"},{"location":"#","page":"Home","title":"Home","text":"note: Note\nIf it is desirable to keep fields as an implementation detail, combining trait functions and Setfield.FunctionLens may be useful:OutputBy(x) = typeof(x)\nOutputBy(::Type{<:Add{O}}) where O = O()\n\nusing Setfield: Setfield, @lens\nSetfield.set(add::Add, ::typeof(@lens OutputBy(_)), o::OutputBy) =\n    @set add.outputby = o\n\nobj = (add=add3!,)\nobj′ = @set OutputBy(obj.add) = Returning()\nobj′ === (add=add3,)\n\n# output\n\ntrueSetfield.set(::Type{Add{O0, T}}, ::typeof(@lens OutputBy(_)), ::O1) where {O0, T, O1 <: OutputBy} =\n    Add{O1, T}\n\nT1 = typeof(add3!)\nT2 = @set OutputBy(T1) = Returning()\nT2 <: Add{Returning}\n\n# output\n\ntrue","category":"page"}]
}
