var documenterSearchIndex = {"docs":
[{"location":"#ConstructionBase.jl","page":"Home","title":"ConstructionBase.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"ConstructionBase allows flexible construction and destructuring of objects. There are two levels of under which this can be done:","category":"page"},{"location":"#the-raw-level","page":"Home","title":"The raw level","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This is where Base.fieldnames, Base.getfield, Base.setfield! live. This level is what an object is ultimately composed of including all private details. At the raw level ConstructionBase adds constructorof and getfields.","category":"page"},{"location":"#the-semantic-level","page":"Home","title":"The semantic level","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This is where Base.propertynames, Base.getproperty and Base.setproperty! live. This level is typically the public interface of a type, it may hide private details and do magic tricks. At the semantic level ConstructionBase adds setproperties and getproperties.","category":"page"},{"location":"#Interface","page":"Home","title":"Interface","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"ConstructionBase\nConstructionBase.constructorof\nConstructionBase.getfields\nConstructionBase.getproperties\nConstructionBase.setproperties","category":"page"},{"location":"#ConstructionBase","page":"Home","title":"ConstructionBase","text":"ConstructionBase\n\n(Image: Stable) (Image: Dev) (Image: Build Status) (Image: GitHub stars)\n\nConstructionBase is a very lightwight package, that provides primitive functions for construction of objects:\n\nsetproperties(obj::MyType, patch::NamedTuple)\nconstructorof(MyType)\n\nThese functions can be overloaded and doing so provides interoperability with the following packages:\n\nFlatten.jl\nSetfield.jl\nBangBang.jl\nAccessors.jl\nModelParameters.jl\n\n\n\n\n\n","category":"module"},{"location":"#ConstructionBase.constructorof","page":"Home","title":"ConstructionBase.constructorof","text":"constructorof(T::Type) -> constructor\n\nReturn an object constructor that can be used to construct objects of type T from their field values. Typically constructor will be the type T with all parameters removed:\n\njulia> using ConstructionBase\n\njulia> struct T{A,B}\n           a::A\n           b::B\n       end\n\njulia> constructorof(T{Int,Int})\nT\n\nIt is however not guaranteed, that constructor is a type at all:\n\njulia> struct S\n           a\n           b\n           checksum\n           S(a,b) = new(a,b,a+b)\n       end\n\njulia> ConstructionBase.constructorof(::Type{<:S}) =\n           (a, b, checksum=a+b) -> (@assert a+b == checksum; S(a,b))\n\njulia> constructorof(S)(1,2)\nS(1, 2, 3)\n\njulia> constructorof(S)(1,2,4)\nERROR: AssertionError: a + b == checksum\n\nInstead constructor can be any object that satisfies the following properties:\n\nIt must be possible to reconstruct an object from the elements of getfields:\n\nctor = constructorof(typeof(obj))\n@assert obj == ctor(getfields(obj)...)\n@assert typeof(obj) == typeof(ctor(getfields(obj)...))\n\nThe other direction should hold for as many values of args as possible:\n\nctor = constructorof(T)\ngetfields(ctor(args...)) == args\n\nFor instance given a suitable parametric type it should be possible to change the type of its fields:\n\njulia> struct T{A,B}\n           a::A\n           b::B\n       end\n\njulia> t = T(1,2)\nT{Int64, Int64}(1, 2)\n\njulia> constructorof(typeof(t))(1.0, 2)\nT{Float64, Int64}(1.0, 2)\n\njulia> constructorof(typeof(t))(10, 2)\nT{Int64, Int64}(10, 2)\n\nconstructorof belongs to the raw level. constructorof is generated for all anonymous Functions lacking constructors, identified as having gensym # in their names. A custom struct <: Function with a gensym name may need to define constructorof manually.\n\nSee also Tips section in the manual\n\n\n\n\n\n","category":"function"},{"location":"#ConstructionBase.getfields","page":"Home","title":"ConstructionBase.getfields","text":"getfields(obj) -> NamedTuple\ngetfields(obj::Tuple) -> Tuple\n\nReturn a NamedTuple containing the fields of obj. On Tuples getfields is the identity function instead, since Tuple fields have no symbolic names.\n\nExamples\n\njulia> using ConstructionBase\n\njulia> struct S{A,B}\n           a::A\n           b::B\n       end\n\njulia> getfields(S(1,2))\n(a = 1, b = 2)\n\njulia> getfields((a=10,b=20))\n(a = 10, b = 20)\n\njulia> getfields((4,5,6))\n(4, 5, 6)\n\nSpecification\n\ngetfields belongs to the the raw level. Semantically getfields boils down to getfield and fieldnames:\n\nfunction getfields(obj::T) where {T}\n    fnames = fieldnames(T)\n    NamedTuple{fnames}(getfield.(Ref(obj), fnames))\nend\n\nHowever the actual implementation can be more optimized. For builtin types, there can also be deviations from this semantics:\n\ngetfields(::Tuple)::Tuple since Tuples don't have symbolic fieldnames\nThere are some types in Base that have undef fields. Since accessing these results in an error, getfields instead just omits these.\n\nImplementation\n\nThe semantics of getfields should not be changed for user defined types. It should  return the raw fields as a NamedTuple in the struct order. In other words it should be equivalent to\n\nfunction getfields(obj::T) where {T}\n    fnames = fieldnames(T)\n    NamedTuple{fnames}(getfield.(Ref(obj), fnames))\nend\n\neven if that includes private fields of obj. If a change of semantics is desired, consider overloading getproperties instead. See also getproperties, constructorof\n\n\n\n\n\n","category":"function"},{"location":"#ConstructionBase.getproperties","page":"Home","title":"ConstructionBase.getproperties","text":"getproperties(obj)::NamedTuple\ngetproperties(obj::Tuple)::Tuple\n\nReturn the properties of obj as a NamedTuple. Since Tuple don't have symbolic properties, getproperties is the identity function on tuples.\n\nExamples\n\njulia> using ConstructionBase\n\njulia> struct S\n           a\n           b\n           c\n       end\n\njulia> s = S(1, 2, 3)\nS(1, 2, 3)\n\njulia> getproperties(s)\n(a = 1, b = 2, c = 3)\n\njulia> getproperties((10,20))\n(10, 20)\n\nSpecification\n\ngetproperties belongs to the semantic level. getproperties guarantees a couple of invariants. When overloading it, the user is responsible for ensuring them:\n\ngetproperties should be consistent with Base.propertynames, Base.getproperty, Base.setproperty!.   Semantically it should be equivalent to:  julia  function getproperties(obj)      fnames = propertynames(obj)      NamedTuple{fnames}(getproperty.(Ref(obj), fnames))  end\ngetproperties is defined in relation to setproperties so that:\nobj == setproperties(obj, getproperties(obj))\nThe only exception from this semantics is that undefined properties may be avoided  in the return value of getproperties.\n\nImplementation\n\ngetproperties is defined by default for all objects. It should be very rare that a custom type MyType, has to implement getproperties(obj::MyType). Reasons to do so are undefined fields or performance considerations.\n\n\n\n\n\n","category":"function"},{"location":"#ConstructionBase.setproperties","page":"Home","title":"ConstructionBase.setproperties","text":"setproperties(obj, patch::NamedTuple)\n\nReturn a copy of obj with properties updates according to patch.\n\nExamples\n\njulia> using ConstructionBase\n\njulia> struct S\n           a\n           b\n           c\n       end\n\njulia> s = S(1,2,3)\nS(1, 2, 3)\n\njulia> setproperties(s, (a=10,c=4))\nS(10, 2, 4)\n\njulia> setproperties((a=1,c=2,b=3), (a=10,c=4))\n(a = 10, c = 4, b = 3)\n\nThere is also a convenience method, which builds the patch argument from keywords:\n\nsetproperties(obj; kw...)\n\nExamples\n\njulia> using ConstructionBase\n\njulia> struct S\n           a\n           b\n           c\n       end\n\njulia> o = S(10, 2, 4)\nS(10, 2, 4)\n\njulia> setproperties(o, a=\"A\", c=\"cc\")\nS(\"A\", 2, \"cc\")\n\nSpecification\n\nsetproperties belongs to the semantic level. If satisfies the following invariants:\n\nPurity: setproperties is supposed to have no side effects. In particular setproperties(obj, patch::NamedTuple) may not mutate obj.\nRelation to propertynames and fieldnames: setproperties relates to propertynames and getproperty, not to fieldnames and getfield. This means that any subset p₁, p₂, ..., pₙ of propertynames(obj) is a valid set of properties, with respect to which the lens laws below must hold.\nsetproperties is defined in relation to getproperties so that:\nobj == setproperties(obj, getproperties(obj))\nsetproperties should satisfy the lens laws:\n\nFor any valid set of properties p₁, p₂, ..., pₙ, following equalities must hold:\n\nYou get what you set.\n\nlet obj′ = setproperties(obj, ($p₁=v₁, $p₂=v₂, ..., $pₙ=vₙ))\n    @assert obj′.$p₁ == v₁\n    @assert obj′.$p₂ == v₂\n    ...\n    @assert obj′.$pₙ == vₙ\nend\n\nSetting what was already there changes nothing:\n\n@assert setproperties(obj, ($p₁=obj.$p₁, $p₂=obj.$p₂, ..., $pₙ=obj.$pₙ)) == obj\n\nThe last set wins:\n\nlet obj′ = setproperties(obj, ($p₁=v₁, $p₂=v₂, ..., $pₙ=vₙ)),\n    obj′′ = setproperties(obj′, ($p₁=w₁, $p₂=w₂, ..., $pₙ=wₙ))\n    @assert obj′′.$p₁ == w₁\n    @assert obj′′.$p₂ == w₂\n    ...\n    @assert obj′′.$pₙ == wₙ\nend\n\nImplementation\n\nFor a custom type MyType, a method setproperties(obj::MyType, patch::NamedTuple) may be defined. When doing so it is important to ensure compliance with the specification.\n\nPrefer to overload constructorof whenever makes sense (e.g., no getproperty method is defined).  Default setproperties is defined in terms of constructorof and getproperties.\nIf getproperty is customized, it may be a good idea to define setproperties.\n\nwarning: Warning\nThe signature setproperties(obj::MyType; kw...) should never be overloaded. Instead setproperties(obj::MyType, patch::NamedTuple) should be overloaded.\n\n\n\n\n\n","category":"function"},{"location":"#type-tips","page":"Home","title":"Tips for designing types","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"When designing types from scratch, it is often possible to structure the types in such a way that overloading constructorof or setproperties is unnecessary in the first place.  It let types in your package work nicely with the ecosystem built on top of ConstructionBase even without explicitly depending on it. For simple structs whose type parameters can be determined from field values, ConstructionBase works without any customization, provided that the \"type-less\" constructor exists.  However, it is often useful or required to have type parameters that cannot be determined from field values. One way to solve this problem is to define singleton types that would determine the type parameters:","category":"page"},{"location":"","page":"Home","title":"Home","text":"abstract type OutputBy end\nstruct Mutating <: OutputBy end\nstruct Returning <: OutputBy end\n\nstruct Add{O <: OutputBy, T}\n    outputby::O\n    value::T\nend\n\n(f::Add{Mutating})(y, x) = y .= x .+ f.value\n(f::Add{Returning})(x) = x .+ f.value\n\nadd1! = Add(Mutating(), 1)\n\nusing ConstructionBase\nadd2 = constructorof(typeof(add1!))(Returning(), 2)\nadd2(1)\n\n# output\n\n3","category":"page"},{"location":"","page":"Home","title":"Home","text":"setproperties works as well:","category":"page"},{"location":"","page":"Home","title":"Home","text":"add3 = setproperties(add2; value=3)\nadd3(1)\n\n# output\n\n4","category":"page"},{"location":"","page":"Home","title":"Home","text":"Note that no overloading of ConstructionBase functions was required. Importantly, this also provides an interface to change type parameters out-of-the-box:","category":"page"},{"location":"","page":"Home","title":"Home","text":"add3! = setproperties(add3; outputby=Mutating())\nadd3!([0], 1)\n\n# output\n\n1-element Vector{Int64}:\n 4","category":"page"},{"location":"","page":"Home","title":"Home","text":"Furthermore, it would work with packages depending on ConstructionBase such as Setfield.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Setfield: @set\nadd3′ = @set add3!.outputby = Returning()\nadd3′ === add3\n\n# output\n\ntrue","category":"page"},{"location":"","page":"Home","title":"Home","text":"note: Note\nIf it is desirable to keep fields as an implementation detail, combining trait functions and Setfield.FunctionLens may be useful:OutputBy(x) = typeof(x)\nOutputBy(::Type{<:Add{O}}) where O = O()\n\nusing Setfield: Setfield, @lens\nSetfield.set(add::Add, ::typeof(@lens OutputBy(_)), o::OutputBy) =\n    @set add.outputby = o\n\nobj = (add=add3!,)\nobj′ = @set OutputBy(obj.add) = Returning()\nobj′ === (add=add3,)\n\n# output\n\ntrueSetfield.set(::Type{Add{O0, T}}, ::typeof(@lens OutputBy(_)), ::O1) where {O0, T, O1 <: OutputBy} =\n    Add{O1, T}\n\nT1 = typeof(add3!)\nT2 = @set OutputBy(T1) = Returning()\nT2 <: Add{Returning}\n\n# output\n\ntrue","category":"page"}]
}
