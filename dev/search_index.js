var documenterSearchIndex = {"docs":
[{"location":"#ConstructionBase.jl-1","page":"Home","title":"ConstructionBase.jl","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"","category":"page"},{"location":"#","page":"Home","title":"Home","text":"ConstructionBase\nConstructionBase.constructorof\nConstructionBase.setproperties","category":"page"},{"location":"#ConstructionBase","page":"Home","title":"ConstructionBase","text":"ConstructionBase\n\n(Image: Stable) (Image: Dev) (Image: Build Status) (Image: Codecov) (Image: GitHub stars)\n\nConstructionBase is a very lightwight package, that provides primitive functions for construction of objects:\n\nsetproperties(obj::MyType, patch::NamedTuple)\nconstructorof(MyType)\n\nThese functions can be overloaded and doing so provides interoperability with the following packages:\n\nFlatten.jl\nSetfield.jl\nBangBang.jl\n\n\n\n\n\n","category":"module"},{"location":"#ConstructionBase.constructorof","page":"Home","title":"ConstructionBase.constructorof","text":"constructorof(T::Type) -> constructor\n\nReturn an object constructor that can be used to construct objects of type T from their field values. Typically constructor will be the type T with all parameters removed:\n\njulia> using ConstructionBase\n\njulia> struct T{A,B}\n           a::A\n           b::B\n       end\n\njulia> constructorof(T{Int,Int})\nT\n\nIt is however not guaranteed, that constructor is a type at all:\n\njulia> struct S\n           a\n           b\n           checksum\n           S(a,b) = new(a,b,a+b)\n       end\n\njulia> ConstructionBase.constructorof(::Type{<:S}) =\n           (a, b, checksum=a+b) -> (@assert a+b == checksum; S(a,b))\n\njulia> constructorof(S)(1,2)\nS(1, 2, 3)\n\njulia> constructorof(S)(1,2,4)\nERROR: AssertionError: a + b == checksum\n\nInstead constructor can be any object that satisfies the following properties:\n\nIt must be possible to reconstruct an object from its fields:\n\nctor = constructorof(typeof(obj))\n@assert obj == ctor(fieldvalues(obj)...)\n@assert typeof(obj) == typeof(ctor(fieldvalues(obj)...))\n\nThe other direction should hold for as many values of args as possible:\n\nctor = constructorof(T)\nfieldvalues(ctor(args...)) == args\n\nFor instance given a suitable parametric type it should be possible to change the type of its fields:\n\njulia> struct T{A,B}\n           a::A\n           b::B\n       end\n\njulia> t = T(1,2)\nT{Int64,Int64}(1, 2)\n\njulia> constructorof(typeof(t))(1.0, 2)\nT{Float64,Int64}(1.0, 2)\n\njulia> constructorof(typeof(t))(10, 2)\nT{Int64,Int64}(10, 2)\n\n\n\n\n\n","category":"function"},{"location":"#ConstructionBase.setproperties","page":"Home","title":"ConstructionBase.setproperties","text":"setproperties(obj, patch::NamedTuple)\n\nReturn a copy of obj with attributes updates accoring to patch.\n\nExamples\n\njulia> using ConstructionBase\n\njulia> struct S\n           a\n           b\n           c\n       end\n\njulia> s = S(1,2,3)\nS(1, 2, 3)\n\njulia> setproperties(s, (a=10,c=4))\nS(10, 2, 4)\n\njulia> setproperties((a=1,c=2,b=3), (a=10,c=4))\n(a = 10, c = 4, b = 3)\n\nThere is also a convenience method, which builds the patch argument from keywords:\n\nsetproperties(obj; kw...)\n\nExamples\n\njulia> using ConstructionBase\n\njulia> struct S\n           a\n           b\n           c\n       end\n\njulia> o = S(10, 2, 4)\nS(10, 2, 4)\n\njulia> setproperties(o, a=\"A\", c=\"cc\")\nS(\"A\", 2, \"cc\")\n\nImplementation\n\nFor a custom type MyType, a method setproperties(obj::MyType, patch::NamedTuple) may be defined.\n\nPrefer to overload constructorof whenever makes sense (e.g., no getproperty method is defined).  Default setproperties is defined in terms of constructorof.\nIf getproperty is customized, it may be a good idea to define setproperties.\n\nwarning: Warning\nThe signature setproperties(obj::MyType; kw...) should never be overloaded. Instead setproperties(obj::MyType, patch::NamedTuple) should be overloaded.\n\nSpecification\n\nsetproperties guarantees a couple of invariants. When overloading it, the user is responsible for ensuring them:\n\nPurity: setproperties is supposed to have no side effects. In particular setproperties(obj, patch::NamedTuple) may not mutate obj.\nRelation to propertynames and fieldnames: setproperties relates to propertynames and getproperty, not to fieldnames and getfield. This means that any subset p₁, p₂, ..., pₙ of propertynames(obj) is a valid set of properties, with respect to which the lens laws below must hold.\nsetproperties should satisfy the lens laws:\n\nFor any valid set of properties p₁, p₂, ..., pₙ, following equalities must hold:\n\nYou get what you set.\n\nlet obj′ = setproperties(obj, ($p₁=v₁, $p₂=v₂, ..., $pₙ=vₙ))\n    @assert obj′.$p₁ == v₁\n    @assert obj′.$p₂ == v₂\n    ...\n    @assert obj′.$pₙ == vₙ\nend\n\nSetting what was already there changes nothing:\n\n@assert setproperties(obj, ($p₁=obj.$p₁, $p₂=obj.$p₂, ..., $pₙ=obj.$pₙ)) == obj\n\nThe last set wins:\n\nlet obj′ = setproperties(obj, ($p₁=v₁, $p₂=v₂, ..., $pₙ=vₙ)),\n    obj′′ = setproperties(obj′, ($p₁=w₁, $p₂=w₂, ..., $pₙ=wₙ))\n    @assert obj′′.$p₁ == w₁\n    @assert obj′′.$p₂ == w₂\n    ...\n    @assert obj′′.$pₙ == wₙ\nend\n\n\n\n\n\n","category":"function"}]
}
